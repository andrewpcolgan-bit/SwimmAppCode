//
//  PracticeListView.swift
//

import SwiftUI
import UniformTypeIdentifiers

// MARK: - PracticeListView

struct PracticeListView: View {
    @EnvironmentObject var appData: AppData

    // Search
    @State private var searchText = ""

    // Filters
    @State private var datePreset: DatePreset = .all
    @State private var selectedAMPM: AMPMFilter = .any
    @State private var typeFilters: Set<TypeToken> = []
    @State private var yardageMin: Int? = nil
    @State private var hasPDFOnly = false

    // Sorting
    @State private var sortOrder: SortOrder = .newest

    // Share
    @State private var shareURL: URL? = nil
    @State private var showingShare = false

    var body: some View {
        List {
            // Compact top: title + stats + filters + sort + search
            Section {
                VStack(alignment: .leading, spacing: 8) {
                    headerSummary
                    filterChipsRow
                    sortBar
                    inlineSearchBar
                }
                .padding(.top, 2)
                .padding(.bottom, 4)
            }
            .listRowBackground(Color.clear)

            // Grouped results
            ForEach(groupedByMonth.keys.sorted(by: >), id: \.self) { monthKey in
                if let bucket = groupedByMonth[monthKey] {
                    Section {
                        ForEach(bucket) { p in
                            let url = appData.pdfURL(for: p.id)
                            let hasPDFFlag = FileManager.default.fileExists(atPath: url.path)

                            NavigationLink {
                                PracticeDetailView(practice: p)
                                    .environmentObject(appData)
                            } label: {
                                PastPracticeRow(
                                    practice: p,
                                    pdfURL: hasPDFFlag ? url : nil,
                                    hasPDF: hasPDFFlag,
                                    share: { shareURL in
                                        self.shareURL = shareURL
                                        self.showingShare = true
                                    }
                                )
                            }
                            .listRowInsets(EdgeInsets(top: 8, leading: 16, bottom: 8, trailing: 16))
                            .listRowBackground(Color.clear)
                            .swipeActions(edge: .trailing) {
                                if hasPDFFlag {
                                    Button {
                                        shareURL = url
                                        showingShare = true
                                    } label: {
                                        Label("Share PDF", systemImage: "square.and.arrow.up")
                                    }.tint(.teal)
                                }
                                Button(role: .destructive) {
                                    appData.deletePractice(p)
                                } label: {
                                    Label("Delete", systemImage: "trash")
                                }
                            }
                        }
                    } header: {
                        HStack {
                            Text(monthKey)
                                .font(.headline)
                            Spacer()
                            let yards = bucket.reduce(0) { $0 + $1.distanceYards }
                            Text("\(bucket.count) • \(yards.formatted(.number.grouping(.automatic))) yds")
                                .font(.caption)
                                .foregroundStyle(.secondary)
                        }
                    }
                }
            }

            if filteredSortedPractices.isEmpty {
                Section {
                    VStack(spacing: 10) {
                        Image(systemName: "magnifyingglass")
                            .font(.system(size: 40))
                            .foregroundStyle(.secondary)
                        Text("No practices match your filters")
                            .font(.headline)
                        Text("Try clearing some chips or search terms.")
                            .font(.subheadline)
                            .foregroundStyle(.secondary)
                    }
                    .frame(maxWidth: .infinity)
                    .padding(.vertical, 28)
                }
                .listRowBackground(Color.clear)
            }
        }
        .listStyle(.insetGrouped)
        .navigationTitle("Past Practices")
        .sheet(isPresented: $showingShare) {
            if let url = shareURL {
                ShareSheet(activityItems: [url])
            }
        }
    }

    // MARK: - Header summary (more compact)

    private var headerSummary: some View {
        let rows = filteredSortedPractices
        let totalYards = rows.reduce(0) { $0 + $1.distanceYards }
        let totalMins = rows.reduce(0) { $0 + max(0, $1.durationMinutes) }

        return VStack(alignment: .leading, spacing: 4) {

            Text("\(rows.count) practices • \(totalYards.formatted(.number.grouping(.automatic))) yds • \(formatTotalMinutes(totalMins))")
                .font(.footnote)
                .foregroundStyle(.secondary)
        }
    }

    // MARK: - Filter chips

    private var filterChipsRow: some View {
        VStack(alignment: .leading, spacing: 6) {
            // Row 1: Date presets
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(DatePreset.allCases, id: \.self) { preset in
                        Chip(text: preset.label, isActive: datePreset == preset) {
                            datePreset = preset
                        }
                    }
                    Chip(icon: "doc.text.fill", text: "Has PDF", isActive: hasPDFOnly) {
                        hasPDFOnly.toggle()
                    }
                }
                .padding(.vertical, 2)
            }

            // Row 2: AM/PM + type
            ScrollView(.horizontal, showsIndicators: false) {
                HStack(spacing: 8) {
                    ForEach(AMPMFilter.allCases, id: \.self) { f in
                        Chip(text: f.label, isActive: selectedAMPM == f) {
                            selectedAMPM = f
                        }
                    }

                    ForEach(TypeToken.allCases, id: \.self) { token in
                        Chip(text: token.label, isActive: typeFilters.contains(token)) {
                            if typeFilters.contains(token) { typeFilters.remove(token) }
                            else { typeFilters.insert(token) }
                        }
                    }

                    Chip(text: yardageMin == nil ? "> 5k yds" : "> \(yardageMin!.formatted())",
                         isActive: yardageMin != nil) {
                        if yardageMin == nil { yardageMin = 5000 } else { yardageMin = nil }
                    }
                }
                .padding(.vertical, 2)
            }
        }
    }

    // MARK: - Sort Bar

    private var sortBar: some View {
        Picker("Sort", selection: $sortOrder) {
            ForEach(SortOrder.allCases, id: \.self) { s in
                Text(s.label).tag(s)
            }
        }
        .pickerStyle(.segmented)
    }

    // MARK: - Inline search bar (date-based search)

    private var inlineSearchBar: some View {
        HStack(spacing: 8) {
            Image(systemName: "magnifyingglass")
                .foregroundStyle(.secondary)

            TextField("Search by date…", text: $searchText)
                .textInputAutocapitalization(.never)
                .disableAutocorrection(true)
        }
        .padding(.horizontal, 10)
        .padding(.vertical, 8)
        .background(Color(.systemGray5))
        .cornerRadius(10)
    }

    // MARK: - Data pipelines

    private var filteredSortedPractices: [AnalyzedPractice] {
        let base = appData.loggedPractices

        // Search: by date text only
        let searched: [AnalyzedPractice]
        if searchText.trimmingCharacters(in: .whitespacesAndNewlines).isEmpty {
            searched = base
        } else {
            let q = searchText.lowercased()
            searched = base.filter { p in
                let hay = searchableDateString(for: p)
                return hay.contains(q)
            }
        }

        // Date preset filter
        let now = Date()
        let filteredByDate = searched.filter { p in
            guard let d = ISO8601DateFormatter().date(from: p.date) else { return true }
            switch datePreset {
            case .all: return true
            case .last7:
                return d >= Calendar.current.date(byAdding: .day, value: -7, to: now)!
            case .last30:
                return d >= Calendar.current.date(byAdding: .day, value: -30, to: now)!
            case .thisSeason:
                let seasonStart = seasonStartDate(reference: now)
                return d >= seasonStart
            }
        }

        // AM/PM filter
        let filteredByAMPM = filteredByDate.filter { p in
            switch selectedAMPM {
            case .any: return true
            case .am: return ampm(for: p) == "AM"
            case .pm: return ampm(for: p) == "PM"
            }
        }

        // Type filters (tokens)
        let filteredByType: [AnalyzedPractice]
        if typeFilters.isEmpty {
            filteredByType = filteredByAMPM
        } else {
            filteredByType = filteredByAMPM.filter { p in
                let tag = ((p.practiceTag ?? "") + " " + p.aiSummary).lowercased()
                return typeFilters.contains { $0.matches(in: tag) }
            }
        }

        // Yardage threshold
        let filteredByYards = filteredByType.filter { p in
            if let min = yardageMin { return p.distanceYards >= min }
            return true
        }

        // Has PDF
        let filteredByPDF = filteredByYards.filter { p in
            let url = appData.pdfURL(for: p.id)
            return hasPDFOnly ? FileManager.default.fileExists(atPath: url.path) : true
        }

        // Sort
        return filteredByPDF.sorted(by: sortOrder.compare)
    }

    private var groupedByMonth: [String: [AnalyzedPractice]] {
        Dictionary(grouping: filteredSortedPractices) { p in
            guard let d = ISO8601DateFormatter().date(from: p.date) else { return "Unknown" }
            let f = DateFormatter()
            f.dateFormat = "LLLL yyyy" // "November 2025"
            return f.string(from: d)
        }
    }

    // MARK: - Small helpers

    private func searchableDateString(for p: AnalyzedPractice) -> String {
        // Build a big lowercase date string so user can type "nov", "11/16", "2025", etc.
        guard let d = ISO8601DateFormatter().date(from: p.date) else {
            return p.date.lowercased()
        }

        let named = DateFormatter()
        named.locale = Locale(identifier: "en_US_POSIX")
        named.dateFormat = "EEEE MMM d yyyy" // "Sunday Nov 16 2025"

        let numeric = DateFormatter()
        numeric.locale = Locale(identifier: "en_US_POSIX")
        numeric.dateFormat = "M/d/yyyy"      // "11/16/2025"

        return (named.string(from: d) + " " + numeric.string(from: d)).lowercased()
    }

    private func seasonStartDate(reference: Date) -> Date {
        // Define season as Aug 1 -> Jul 31
        let cal = Calendar.current
        let comps = cal.dateComponents([.year, .month, .day], from: reference)
        let year = comps.year ?? 2025
        if (comps.month ?? 1) >= 8 {
            return cal.date(from: DateComponents(year: year, month: 8, day: 1))!
        } else {
            return cal.date(from: DateComponents(year: year - 1, month: 8, day: 1))!
        }
    }

    private func ampm(for p: AnalyzedPractice) -> String? {
        switch (p.timeOfDay ?? "").uppercased() {
        case "AM", "MORNING": return "AM"
        case "PM", "AFTERNOON", "EVENING": return "PM"
        default:
            if let date = ISO8601DateFormatter().date(from: p.date) {
                let hour = Calendar.current.component(.hour, from: date)
                return hour < 12 ? "AM" : "PM"
            }
            return nil
        }
    }

    private func formatTotalMinutes(_ minutes: Int) -> String {
        guard minutes > 0 else { return "0m" }
        let h = minutes / 60
        let m = minutes % 60
        if h > 0 && m > 0 { return "\(h)h \(m)m" }
        if h > 0 { return "\(h)h" }
        return "\(m)m"
    }
}

// MARK: - Row View

private struct PastPracticeRow: View {
    let practice: AnalyzedPractice
    let pdfURL: URL?
    let hasPDF: Bool
    let share: (URL) -> Void

    private let rightRailWidth: CGFloat = 108
    private let columnGap: CGFloat = 12

    var body: some View {
        HStack(alignment: .top, spacing: columnGap) {
            // Left column
            VStack(alignment: .leading, spacing: 4) {
                Text(dateSmall(for: practice))
                    .font(.caption)
                    .foregroundStyle(.secondary)

                Text(titleCasedTag(from: practice))
                    .font(.headline.weight(.semibold))
                    .foregroundStyle(.primary)
                    .lineLimit(2)
                    .minimumScaleFactor(0.9)

                HStack(spacing: 6) {
                    if let ampm = ampm(for: practice) {
                        metaChip(text: ampm)
                    }
                    if let t = typeChipText(for: practice) {
                        metaChip(text: t)
                    }
                    if practice.durationMinutes > 0 {
                        Text("• \(formatTotalMinutes(practice.durationMinutes))")
                            .font(.caption2)
                            .foregroundStyle(.secondary)
                    }
                }
                .padding(.top, 2)

                if let line = compactSectionLine(from: practice.sectionYards) {
                    Text(line)
                        .font(.caption2)
                        .foregroundStyle(.secondary)
                        .padding(.top, 6)
                }
            }
            .frame(maxWidth: .infinity, alignment: .leading)

            // Right rail
            VStack(alignment: .trailing, spacing: 2) {
                Text(practice.distanceYards.formatted(.number.grouping(.automatic)))
                    .font(.system(size: 28, weight: .bold, design: .rounded))
                    .foregroundStyle(.primary)
                    .fixedSize()

                HStack(spacing: 4) {
                    Text("yds")
                        .font(.caption2.weight(.semibold))
                        .foregroundStyle(.teal)
                    Image(systemName: "chevron.right")
                        .font(.caption2.weight(.bold))
                        .foregroundStyle(.secondary)
                }

                if hasPDF, let url = pdfURL {
                    Button {
                        share(url)
                    } label: {
                        Image(systemName: "doc.text.fill")
                            .foregroundStyle(.teal)
                    }
                    .padding(.top, 6)
                }
            }
            .frame(width: rightRailWidth, alignment: .trailing)
        }
        .contentShape(Rectangle())
        .padding(.vertical, 6)
    }

    // MARK: helpers (row)

    private func dateSmall(for p: AnalyzedPractice) -> String {
        guard let d = ISO8601DateFormatter().date(from: p.date) else { return "—" }
        let f = DateFormatter()
        f.dateFormat = "E, MMM d"
        return f.string(from: d)
    }

    private func ampm(for p: AnalyzedPractice) -> String? {
        switch (p.timeOfDay ?? "").uppercased() {
        case "AM", "MORNING": return "AM"
        case "PM", "AFTERNOON", "EVENING": return "PM"
        default:
            if let date = ISO8601DateFormatter().date(from: p.date) {
                return Calendar.current.component(.hour, from: date) < 12 ? "AM" : "PM"
            }
            return nil
        }
    }

    private func titleCasedTag(from p: AnalyzedPractice) -> String {
        let raw = (p.practiceTag?.trimmingCharacters(in: .whitespacesAndNewlines)).flatMap { $0.isEmpty ? nil : $0 }
            ?? "Unlabeled session"
        let words = raw.split(separator: " ")
        let mapped = words.map { token -> String in
            if token.uppercased() == token { return String(token) }
            return token
                .split(separator: "-")
                .map { part in
                    var s = String(part)
                    guard let first = s.first else { return s }
                    s.replaceSubrange(s.startIndex...s.startIndex, with: String(first).uppercased())
                    return s
                }
                .joined(separator: "-")
        }
        return mapped.joined(separator: " ")
    }

    private func metaChip(text: String) -> some View {
        Text(text)
            .font(.caption2.weight(.semibold))
            .foregroundStyle(.secondary)
            .padding(.horizontal, 8)
            .padding(.vertical, 3)
            .background(
                RoundedRectangle(cornerRadius: 8, style: .continuous)
                    .fill(Color.white.opacity(0.16))
                    .overlay(
                        RoundedRectangle(cornerRadius: 8, style: .continuous)
                            .stroke(Color.white.opacity(0.22), lineWidth: 0.5)
                    )
            )
    }

    private func compactSectionLine(from dict: [String: Int]) -> String? {
        let order = ["Warmup", "Preset", "Main Set", "Post-Set", "Cooldown"]
        let abbreviations: [String: String] = [
            "Warmup": "Warmup",
            "Preset": "Preset",
            "Main Set": "Main",
            "Post-Set": "Post",
            "Cooldown": "CD"
        ]
        var parts: [String] = []
        for key in order {
            if let v = match(dict, key: key), v > 0 {
                parts.append("\(abbreviations[key] ?? key) \(v.formatted(.number.grouping(.automatic)))")
            }
        }
        return parts.isEmpty ? nil : parts.joined(separator: " • ")
    }

    private func match(_ dict: [String: Int], key: String) -> Int? {
        dict.first(where: { k, _ in
            k.compare(key, options: [.caseInsensitive, .diacriticInsensitive]) == .orderedSame ||
            k.replacingOccurrences(of: "-", with: " ")
                .compare(key.replacingOccurrences(of: "-", with: " "),
                         options: [.caseInsensitive, .diacriticInsensitive]) == .orderedSame
        })?.value
    }

    private func typeChipText(for p: AnalyzedPractice) -> String? {
        let s = ((p.practiceTag ?? "") + " " + p.aiSummary).lowercased()
        if s.contains("im") { return "IM" }
        if s.contains("mid") && s.contains("distance") { return "Mid-Distance" }
        if s.contains("sprint") || s.contains("race-pace") || s.contains("race pace") { return "Race-Pace" }
        if s.contains("threshold") { return "Threshold" }
        if s.contains("aerobic") { return "Aerobic" }
        if s.contains("kick") { return "Kick" }
        if s.contains("pull") { return "Pull" }
        return nil
    }

    private func formatTotalMinutes(_ minutes: Int) -> String {
        guard minutes > 0 else { return "0m" }
        let h = minutes / 60
        let m = minutes % 60
        if h > 0 && m > 0 { return "\(h)h \(m)m" }
        if h > 0 { return "\(h)h" }
        return "\(m)m"
    }
}

// MARK: - Chips + enums

private struct Chip: View {
    var icon: String? = nil
    let text: String
    let isActive: Bool
    let action: () -> Void

    var body: some View {
        Button(action: action) {
            HStack(spacing: 6) {
                if let icon { Image(systemName: icon) }
                Text(text)
                    .font(.caption.weight(.semibold))
            }
            .padding(.horizontal, 10)
            .padding(.vertical, 6)
            .background(
                RoundedRectangle(cornerRadius: 10, style: .continuous)
                    .fill(isActive ? Color.teal.opacity(0.22) : Color.white.opacity(0.12))
                    .overlay(
                        RoundedRectangle(cornerRadius: 10, style: .continuous)
                            .stroke(isActive ? Color.teal.opacity(0.8) : Color.white.opacity(0.22), lineWidth: 0.8)
                    )
            )
        }
        .buttonStyle(.plain)
        .foregroundStyle(isActive ? .teal : .secondary)
    }
}

private enum DatePreset: CaseIterable {
    case all, last7, last30, thisSeason
    var label: String {
        switch self {
        case .all: return "All"
        case .last7: return "Last 7d"
        case .last30: return "Last 30d"
        case .thisSeason: return "This Season"
        }
    }
}

private enum AMPMFilter: CaseIterable {
    case any, am, pm
    var label: String {
        switch self {
        case .any: return "Any"
        case .am: return "AM"
        case .pm: return "PM"
        }
    }
}

private enum TypeToken: CaseIterable, Hashable {
    case im, midDistance, sprint, threshold, aerobic, kick, pull
    var label: String {
        switch self {
        case .im: return "IM"
        case .midDistance: return "Mid-Distance"
        case .sprint: return "Sprint"
        case .threshold: return "Threshold"
        case .aerobic: return "Aerobic"
        case .kick: return "Kick"
        case .pull: return "Pull"
        }
    }
    func matches(in lowercasedText: String) -> Bool {
        switch self {
        case .im: return lowercasedText.contains(" im ")
            || lowercasedText.hasPrefix("im ")
            || lowercasedText.contains(" im-")
            || lowercasedText.contains(" individual medley")
        case .midDistance: return lowercasedText.contains("mid") && lowercasedText.contains("distance")
        case .sprint: return lowercasedText.contains("sprint") || lowercasedText.contains("race-pace") || lowercasedText.contains("race pace")
        case .threshold: return lowercasedText.contains("threshold")
        case .aerobic: return lowercasedText.contains("aerobic")
        case .kick: return lowercasedText.contains("kick")
        case .pull: return lowercasedText.contains("pull")
        }
    }
}

private enum SortOrder: CaseIterable {
    case newest, oldest, mostYards, longest

    var label: String {
        switch self {
        case .newest: return "Newest"
        case .oldest: return "Oldest"
        case .mostYards: return "Most yds"
        case .longest: return "Longest"
        }
    }

    func compare(_ a: AnalyzedPractice, _ b: AnalyzedPractice) -> Bool {
        let aDate = ISO8601DateFormatter().date(from: a.date)
        let bDate = ISO8601DateFormatter().date(from: b.date)

        switch self {
        case .newest:
            return (aDate ?? .distantPast) > (bDate ?? .distantPast)
        case .oldest:
            return (aDate ?? .distantFuture) < (bDate ?? .distantFuture)
        case .mostYards:
            return a.distanceYards > b.distanceYards
        case .longest:
            return (a.durationMinutes) > (b.durationMinutes)
        }
    }
}

// MARK: - ShareSheet wrapper

private struct ShareSheet: UIViewControllerRepresentable {
    let activityItems: [Any]
    let applicationActivities: [UIActivity]? = nil

    func makeUIViewController(context: Context) -> UIActivityViewController {
        UIActivityViewController(activityItems: activityItems, applicationActivities: applicationActivities)
    }
    func updateUIViewController(_ vc: UIActivityViewController, context: Context) {}
}
